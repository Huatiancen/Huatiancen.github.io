---
layout: post
title: 《数据管理基础》期末整理
date: 2025-05-30 00:57 +0800
last_modified_at: 2025-06-12 16:46 +0800
tags: ['数据管理基础']
toc: true
---

***花天岑 231830117***

## 第一章

计算和数据中间导入数据库的作用

数据管理 主要方式 人工、文件和数据库更适合/不适合什么场景

基本概念 三层模型 两级映射

### 导入数据库的作用/数据库针对什么

为解决多用户、多应用共享数据的需求，使数据为尽可能多的应用服务，数据库技术便应运而生，出现了统一管理数据的专门软件系统--数据库管理系统。

### 跟人工管理和文件系统比较，说明数据库管理数据的特点

![image-20250610221600825](https://huatiancen.oss-cn-nanjing.aliyuncs.com/img/image-20250610221600825.png)

适合用文件系统的例子

- 手机相册（文件系统就够用了，我也不需要共享，不需要使用数据库系统）
- 手机短信（同上）

适合用数据库系统的例子

- 学校的选课系统（比如某一个课程只有固定名额，别人选满了我就不能选了，涉及到并发的问题，不可以用文件系统）
- 学校的图书管理系统（同上）

### 简述数据库三级模式和两级映像的作用和地位。

数据库系统的三级模式结构由外模式、内模式和模式组成。

- 外模式（又称子模式或者用户模式），是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图。
- 模式（又称逻辑模式），是数据库中全体数据的逻辑结构和特性的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。外模式通常是模式的子集
- 内模式（又称存储模式），是数据在数据库系统内部的表示，即对数据的物理结构和存储方法的描述。

为了能够在内部实现这三个抽象层次的联系和转换，数据库系统在这三级模式之间提供了两级映像：外模式/模式映象和模式/内模式映像。正是这两级映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。

二级映像

- 当模式改变时(例如增加新的关系、新的属性、改变属性的数据类型等),由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。
- 模式/内模式映像定义通常包含在模式描述中。当数据库的存储结构改变时(例如选用了另一种存储结构),由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性，简称数据的物理独立性。

### 概念模型的用途

- 概念模型用于信息世界的建模
- 是现实世界到机器世界的一个中间层次
- 是数据库设计的有力工具
- 数据库设计人员和用户之间进行交流的语言

## 第二章

关系基本概念 关系模式 关系数据库 笛卡尔积 码 关系的基本性质 三类完整性约束条件 关系操作 关系代数 详细定义不必知道 关系代数表达语义

### 一些基本概念

- 域：域是一组具有相同数据类型的值的集合

- 笛卡尔积：给定一组域`D1`,`D2`,......,`Dn`,允许其中某些域是有相同的。这组域的笛卡尔积为
  $$
  D_1 \times D_2 \times \cdots \times D_n = \{ (d_1, d_2, \ldots, d_n) \mid d_i \in D_i, i = 1, 2, \ldots, n \}
  $$

- 关系：D₁×D₂×…×Dn的子集叫作在域D₁,D₂,…,Dn上的关系，表示为R(D₁,D₂,…,Dn)

- 元组：关系中每个元素是关系中的元组

- 属性：关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性。

- 候选码：若关系中的某一属性组能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。
- 主码：若一个关系有多个候选码，则选定其中一个为主码。
- 外码：设F是基本关系R的一个或一组属性，但不是关系R的码，如果F与基本关系S的主码K~s~相对应，则称F为基本关系R的外部码

- 关系模式：关系的描述称为关系模式。它可以形式化地表示为$R(U,D,DOM,F)$其中R为关系名，U为组成该关系的属性名集合，D为属性组U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合
- 关系：关系是关系模式在某一时刻的状态或内容。关系模式是静态的、稳定的，而关系式动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。
- 关系数据库：关系数据库也有型和值之分。关系数据库的型称为关系数据库模式，是对关系数据库的描述，它包括若干域的定义以及在这些域上定义的若干关系模式。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。

### 基本关系的性质

- 列是同质的
- 不同的列可以出自相同的域，不同的属性要给予不同的属性名
- 列的顺序可以任意交换
- 任意两个元组的候选码不能取相同的值
- 行顺序可以任意交换
- 分量必须取原子值

### 完整性约束有哪几种，以选课为背景分别举例说明

- 实体完整性
  - 确保关系中的每一个元组（对应表中的每一行记录）都具有唯一的标识。通常通过设置主键（Primary Key）来实现，主键是一组能够唯一标识一个元组的属性或属性组合。
  - 在 “选课” 表中，学号和课程号可以作为联合主键。因为一个学生可以选择多门课程，一门课程也可以被多个学生选择，通过学号和课程号的组合可以唯一确定一条选课记录。这样就能确保每条选课记录都能被唯一标识，方便后续对该记录的操作
- 参照完整性
  - 定义了两个关系之间的引用规则，即在一个表中作为外键（Foreign Key）的属性值必须来自于另一个表中的合法值（该表的主键或被其他表引用的候选键的值）或者为 NULL。
  - 选课表中的 “学号” 作为外键，引用学生信息表中的 “学号” 字段（学生信息表中的主键）；选课表中的 “课程号” 作为外键，引用课程信息表中的 “课程号” 字段（课程信息表中的主键）。这样可以保证选课表中的学号和课程号都是合法的，即必须是学生信息表中存在的学号和课程信息表中存在的课程号
- 用户定义完整性
  - 是根据具体应用环境和业务规则对数据设置的约束条件，包括对属性的取值范围、格式、类型等进行限制。
  - 对 “成绩” 字段设置取值范围约束，例如成绩必须在 0 - 100 分之间。这样可以确保录入的成绩数据是合理的，避免出现如 - 10 分、150 分等不符合实际意义的成绩值。

### 关系的5种基本操作是什么

选择、投影、并、差、笛卡尔积

### 关系代数

见应用题

## 第三章

sql特征不需要 性质需要知道 数据定义 相关语法 含义 数据查询嵌套不做要求 尽量不要用

### sql语法

详细见应用题

## 第四章

级别不用看自主存取控制 怎么做 优缺点 revoke  和grant 强制控制存取 怎么做 优缺点 ch25可以一带而过

### 概述自主访问控制的原理和缺点

自主存取控制方法：定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。

自主存取控制中自主的含义是：用户可以把自己拥有的存取权限“自主”地授予别人。即用户具有一定的“自主”权。

缺点：可能存在数据的“无意泄露”   原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记

### 简述强制访问控制(MAC)的原理

强制存取控制方法：每一个数据对象被(强制地)标以一定的密级，每一个用户也被(强制地)授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。

优点：基于密级和标签的访问控制，确保更高安全性

### 什么是视图 （留个印象）

视图是关系数据库系统提供给用户以多种角度观察数据库中数据的机制。视图是使用`SELECT FROM`语句从一个或多个基本表中导出的表，是一个虚表。

### 视图有什么作用 （留个印象）

- 视图能简化用户的操作
- 视图使用户能以多种视角看待同一数据
- 视图对重构数据库提供了一定程度的逻辑独立性
- 视图能够对机密数据提供安全保护
- 适当的利用视图可以更清晰地表达查询

## 第五章

断言和触发器不作要求 三种检查的相关条件 定义 怎么去做

### 三种检查相关相关条件

- 实体完整性
  - 检查主码值是否唯一，如果不唯一则拒绝插入或修改。
  - 检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。
- 参照完整性

![image-20250611123831827](https://huatiancen.oss-cn-nanjing.aliyuncs.com/img/image-20250611123831827.png)

- 用户定义完整性
  - 针对某一具体应用的数据必须满足的语义要求
  - 属性上的约束条件 元组上的约束条件

## 第六章

不考范式定义 范式BCNF之后的不做要求 哪一级别 如何处理从而提升

见应用题

## 第七章

不用需求分析 E-R图 基本E-R图 不必扩展E-R图 概念结构设计知道就行 逻辑结构设计转换得会做

垂直和水平分解 有利有弊 什么场景适合不适合 物理模型设计有一些优化方式和聚簇要掌握 

### 简要描述数据库设计的6个阶段

1. 需求分析
2. 概念结构设计
3. 逻辑结构设计
4. 物理结构设计
5. 数据库实施
6. 数据库运行和维护

### E-R图与逻辑结构设计转换

见应用题

### 简述逻辑模型设计中，水平分解和垂直分解的原理

- 水平分解是把(基本)关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统的效率。
- 垂直分解是把关系模式R的属性分解为若干子集合，形成若干子关系模式。垂直分解的原则是，将经常在一起使用的属性从R中分解出来形成一个子关系模式。

场景

- 水平分解
  - 适用场景
    - 大型事实表（如日志、交易记录）。
    - 按时间/地域查询的频繁场景（如电商订单按月份拆分）。
    - 需水平扩展的分布式系统（如用户表按ID哈希分片）。
  - 不适用场景：
    - 频繁跨分区关联查询的表（如需要多表JOIN的分析系统）。
    - 数据量小的表（过度设计）。
    - 强事务一致性要求的核心业务表（如银行账户余额表）。
- 垂直分解
  - 适用场景
    - 宽表（列数多）且列访问频率差异大（如用户表拆为基础信息+扩展信息）。
    - 含大字段的表（如文章表分离内容与元数据）。
    - 安全隔离需求（如将密码单独存储）。
  - 不适用场景
    - 表列数少或所有列常被同时查询。
    - JOIN 性能敏感的场景（如实时分析系统）。
    - 无法接受关联查询延迟的应用。

### 聚簇的原理，以教务系统为例分别从正/反两个方面说明其适合/不适合的场景

为了提高某个属性(或属性组)的查询速度，把这个或这些属性上具有相同值的元组集中存放在连续的物理块中称为聚簇。

- 正：学生按专业分组，将同一专业的学生按照课程安排集中存储，便于查询和管理专业课程
- 反：大数据量更新，建立与维护聚簇的开销相当大

### 索引的作用

提供多种存取路径,加快查找速度

## 第十章

事务的定义 ACID 故障恢复的过程  日志检查点怎么做的 数据库镜像不需要 转储和日志需要知道 恢复策略不作要求

### 事务的定义

事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。

### 什么是事务的ACID特性

- 原子性(Atomicity)
  - 操作要么全做，要么全不做
- 一致性(Consistency)
  - 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态，一致性状态指数据库中只包含成功事务提交的结果
- 隔离性(Isolation)
  - 一个事务的执行不能被其他事务干扰
  - 一个事务内部的操作及使用的数据对其他并发事务是隔离的
  - 并发执行的各个事务之间不能互相干扰
- 持续性(Durability)
  - 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。
  - 接下来的其他操作或故障不应该对其执行结果有任何影响。

（故障恢复保证了原子性和持续性）

### 故障恢复的过程

- 事务故障的恢复步骤是：
  - 反向扫描文件日志，查找该事务的更新操作。
  - 对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。直至读到此事务的开始标记，该事务故障的恢复就完成了。
- 系统故障的恢复步骤是：
  - 正向扫描日志文件，找出在故障发生前已经提交的事务队列(REDO队列)和未完成的事务队列(UNDO队列)。
  - 对未完成的事务队列中的各个事务进行UNDO处理。
  - 对已经提交的事务队列中的各个事务进行REDO处理。
- 介质故障的恢复步骤是：
  - 装入最新的数据库后备副本(离故障发生时刻最近的转储副本),使数据库恢复到最近一次转储时的一致性状态。
  - 装入转储结束时刻的日志文件副本。
  - 启动系统恢复命令，由DBMS完成恢复功能，即重做已完成的事务。
- 计算机病毒
  - 课本无，应该是要用恢复技术吧

### 什么是日志文件，有什么用途

日志文件是用来记录事务对数据库更新操作的文件

用途：

- 进行事务故障恢复
- 进行系统故障恢复
- 协助后备副本进行介质故障恢复

### 为什么要先写日志文件再写数据库

- 写数据库和写日志文件是两个不同的操作
- 在这两个操作之间可能发生故障
- 如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了
- 如果先写日志，但没有修改数据库，按日志文件恢复时只不过多执行了一次不必要的UNDO操作，并不会影响数据库的正确性

### 什么是检查点记录

检查点记录是一类新的日志记录。它的内容包括

- 建立检查点时刻所有正在执行的事务清单
- 这些事务的最近一个日志记录的地址

### 具有检查点的恢复技术有什么优点

利用日志技术进行数据库恢复时,恢复子系统必须搜索整个日志，这将耗费大量的时间。此外,需要REDO处理的事务实际上已经将它们的更新操作结果写到数据库中了，恢复子系统又重新执行了这些操作，浪费了大量时间。

### 概述检查点技术的原理，说明使用检查点进行恢复的流程

在日志文件中增加检查点记录，增加重新开始文件，恢复子系统在登录日志文件期间动态地维护日志

1. 在重新开始文件中，找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。
2. 由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。这里建立两个事务队列：UNDO-LIST和REDO-LIST。把ACTIVE-LIST暂时放入UND0-LIST队列，REDO队列暂为空。
3. 从检查点开始正向扫描日志文件，直至文件结束。如有新开始的事务T,把T,暂时放入UNDO-LIST队列；如有提交的事务T,,把T,从UNDO-LIST队列移到REDO-LIST队列，直到日志文件结束。
4. 对UNDO-LIST中的每个事务执行UNDO操作，对REDO-LIST中的每个事务执行REDO操作。

### 转储（了解即可）

转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程

<img src="https://huatiancen.oss-cn-nanjing.aliyuncs.com/img/image-20250611142902472.png" alt="image-20250611142902472" style="zoom:50%;" />

<img src="https://huatiancen.oss-cn-nanjing.aliyuncs.com/img/image-20250611142928865.png" alt="image-20250611142928865" style="zoom:50%;" />

<img src="https://huatiancen.oss-cn-nanjing.aliyuncs.com/img/image-20250611143004492.png" alt="image-20250611143004492" style="zoom:50%;" />



## 第十一章

并发控制 怎么会出问题 为什么不一致性 如何解决不一致性 即封锁 怎么去做的 写锁 三个不同协议 应用方式

死锁活锁概念 解决方式 事务调度基本概念  串行 巴拉巴拉 可串行化巴拉巴拉  意向锁

### 并发操作可能导致什么问题，如何解决不一致性


并发操作带来的数据不一致性包括三类：

- 丢失修改
  - 两个事务T₁和T₂读入同一数据并修改，T₂提交的结果破坏了(覆盖了)T₁提交的结果，导致T₁的修改被丢失。
- 不可重复读
  - 不可重复读是指事务T₁读取某一数据后，事务T₂对其执行更新操作，使T₁无法再现前一次读取结果。不可重复读包括三种情况：
    - 事务T,读取某一数据后，事务T₂对其做了修改，当事务T₁再次读该数据时，得到与前一次不同的值。
    - 事务T₁按一定条件从数据库中读取了某些数据记录后，事务T₂删除了其中部分记录，当T,再次按相同条件读取数据时，发现某些记录消失了。
    - 事务T₁按一定条件从数据库中读取某些数据记录后，事务T₂插人了一些记录，当T₁再次按相同条件读取数据时，发现多了一些记录。
    - （后两种不可重复读有时也称为幻影(phantom row)现象。）
- 读“脏”数据
  - 读“脏”数据是指事务T,修改某一数据，并将其写回磁盘，事务T₂读取同一数据后，T₁由于某种原因被撤销，这时T₁已修改过的数据恢复原值，T₂读到的数据就与数据库中的数据不一致，则T₂读到的数据就为“脏”数据，即不正确的数据。

避免不一致性的方法就是并发控制。常用的并发控制技术包括**封锁**方法、时间戳方法、乐观控制方法和多版本并发控制方法等。

### 封锁基本概念

封锁就是事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新或读取此数据对象。

基本的封锁类型有两种 排他锁(简称X锁)和共享锁(简称S锁)。

- 排他锁又称为写锁。若事务T对数据对象A加上X锁，则只允许T读取和修改A,其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。
- 共享锁又称为读锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A,其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改。

### 三种封锁协议

- 一级封锁协议
  - 事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放
- 二级封锁协议
  - 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁
- 三级封锁协议
  - 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，事务完成后即可释放S锁

![image-20250611150200129](https://huatiancen.oss-cn-nanjing.aliyuncs.com/img/image-20250611150200129.png)

### 活锁

如果事务T₁封锁了数据R,事务T₂又请求封锁R,于是T₂等待。T₃也请求封锁R,当T₁释放了R上的封锁之后系统首先批准了T₃的请求，T₂仍然等待。然后T₄又请求封锁R,当T₃释放了R上的封锁之后系统又批准了T₄的请求……T₂有可能永远等待。活锁的含义是该等待事务等待时间太长，似乎被锁住了，实际上可能被激活。

活锁产生的原因：当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁。

避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。

### 死锁

如果事务T₁封锁了数据R₁,T₂封锁了数据R₂,然后T₁又请求封锁R₂,因T₂已封锁了R₂,于是T₁等待T₂释放R₂上的锁。接着T₂又申请封锁R₁,因T₁已封锁了R₁,T₂也只能等待T₁释放R₁上的锁。这样就出现了T,在等待T₂,而T₂又在等待T,的局面，T₁和T₂两个事务永远不能结束，形成死锁。

防止死锁的发生其实就是要破坏产生死锁的条件。预防死锁通常有两种方法：

- 一次封锁法 要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。
- 顺序封锁法 预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。

数据库系统一般采用的方法是允许死锁发生，DBMS检测到死锁后加以解除。DBMS中诊断死锁的方法与操作系统类似，一般使用超时法或事务等待图法。

超时法是指如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。

DBMS并发控制子系统检测到死锁后，就要设法解除。通常采用的方法是**选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁，使其他事务得以继续运行下去。**

### 可串行化调度

多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同

### 冲突可串行化

一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc',如果Sc'是串行的，称调度Sc是冲突可串行化的调度

### 两段锁

“两段”锁的含义，事务分为两个阶段

- 第一阶段是获得封锁，也称为扩展阶段
  - 事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁
- 第二阶段是释放封锁，也称为收缩阶段
  - 事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁

遵守两段锁协议 就一定可串行化调度

### 为什么要引进意向锁？意向锁的含义是什么

引进意向锁是为了提高封锁子系统的效率

原因是：在多粒度封锁方法中，一个数据对象可能以两种方式加锁——显式封锁和隐式封锁。因此系统在对某一数据对象加锁时，不仅要检查该数据对象上有无（显式和隐式）封锁与之冲突，还要检查其所有上级结点和所有下级结点，看申请的封锁是否与这些结点上的（显式和隐式）封锁冲突。显然，这样的检查方法效率很低。为此引进了意向锁。

意向锁的含义是：对任一结点加锁时，必须先对它的上层结点加意向锁。引进意向锁后，系统对某一数据对象加锁时不必逐个检查与下一级结点的封锁冲突了。







